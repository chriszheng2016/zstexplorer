---
title: "Explore cluster in stock data"
documentclass: ctexart
output:
  html_notebook: 
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
      smooth_scroll: false
    df_print: paged
    code_folding: show
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
      smooth_scroll: false
    df_print: paged
    code_folding: show
params:
  indcd_group:
    label: 'Indcd Group:'
    input: text
    value: 'C37, C38, C39'
  cs_date:
    label: 'Year:'
    input: text
    value: '2019-12-31'
---

```{css, echo=FALSE}

/*Setting for scrollable code/text*/ 

pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 400px;
}

/*Setting for TOC and outlook*/

div.main-container {
  max-width: 100% !important;
}

.tocify {
  max-width: 20% !important;
}

.toc-content {
  padding-left: 5px !important;
}
```

```{r setup, include=FALSE}

# General packages
library(tidyverse)
library(gridExtra)
library(DT)
library(plotly)
library(glue)

# Special packages
library(cluster)
library(factoextra)
library(fpc)
library(clustertend)
library(NbClust)
library(clValid)
library(pvclust)

# My packages
devtools::load_all()

# Set global options for knitr
knitr::opts_chunk$set(
  fig.align = "center",
  fig.show = "hold",
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  results = "hold",
  comment = "#>",
  out.width = "80%",
  tidy = "styler"
)
```

# Prepare data

Parameters for loading data:

**Industry Group:** *`r knitr::combine_words(params$indcd_group)`*

**Date of Cross-sectional data:** *`r cs_date`*

```{r}
indcd_group <- stringr::str_split(params$indcd_group, pattern = ",")
indcd_group <- stringr::str_trim(unlist(indcd_group))
cs_date <- stringr::str_trim(params$cs_date)

csbl_vars <- load_csbl_vars()

df_cluster_raw <-
  csbl_vars %>%
  na.omit() %>%
  dplyr::filter(indcd %in% indcd_group) %>%
  tidyr::separate(id, into = c("date", "period", "stkcd"), sep = "_") %>%
  dplyr::filter(grepl(cs_date, date)) %>%
  dplyr::select(-c("date", "period")) %>%
  # Use median for numeric field of multiple period series of stock
  # Use mode numbers for non-numeric filed of multiple period series of stock
  dplyr::group_by(stkcd) %>%
  dplyr::summarise(
    indcd = names(which.max(table(indcd))),
    across(where(is.numeric), median)
  ) %>%
  # Scale data
  dplyr::mutate(across(where(is.numeric), scale)) %>%
  tibble::column_to_rownames(var = "stkcd")


# data frame for cluster stocks
df_cluster <-
  df_cluster_raw %>%
  dplyr::select(-indcd)

# data frame for comparing indcd
df_cluster_indcd <-
  df_cluster_raw %>%
  dplyr::select(indcd)
```
# Assessing Clustering Tendency

## Statistical method
**The Hopkins statistic** is used to assess the clustering tendency of a data set by measuring the probability that a given data set is generated by a uniform data distribution. In other words, it tests the spatial randomness of the data.

The null and the alternative hypotheses are defined as follow:

* Null hypothesis: the data set D is uniformly distributed (i.e., no meaningful clusters)

* Alternative hypothesis: the data set D is not uniformly distributed (i.e., contains meaningful clusters)

**Rule to judge:**

* If the value of Hopkins statistic is close to 1 (far above 0.5), the dataset is significantly clusterable. 
* If the value of Hopkins statistic is close to 0.5, the dataset is uniformly distributed.


```{r}
set.seed(123)

# Method A: use (1-clustertend::hopkins())
origin_hopkins_stats <- clustertend::hopkins(df_cluster, n = NROW(df_cluster) - 1)
hopkins_res <- 1 - origin_hopkins_stats$H

# Method B: use factoextra::get_clust_tendency()
cluster_trendency <- factoextra::get_clust_tendency(
  df_cluster,
  n = min(10, nrow(df_cluster - 1)),
  graph = FALSE,
  seed = 123
)

hopkins_res <- cluster_trendency$hopkins_stat

hopkins_res
```

## Visual methods(VAT)
### Distance Measures
```{r}
# Set parameters for computing distances
metric <- c("euclidean", "manhattan", "pearson", "spearman", "kendall")
dist_metric <- tidyr::expand_grid(metric)

# Compute distance between stocks
dist_metric <- dist_metric %>%
  dplyr::rowwise() %>%
  dplyr::mutate(dist = list(factoextra::get_dist(
    x = df_cluster,
    method = .data$metric
  )))
```

### Visual assessment of cluster tendency (VAT)
```{r}
# Visualize distance between stocks
dist_metric <- dist_metric %>%
  dplyr::mutate(
    plot = list(factoextra::fviz_dist(.data$dist,
      lab_size = 6
    ) + labs(title = .data$metric))
  )

gridExtra::marrangeGrob(
  grobs = dist_metric$plot,
  ncol = 2, nrow = 2, newpage = FALSE
)

```

# Determining the Optimal Number of Clusters
## Elbow method
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "wss")
```

## Average silhouette method
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "silhouette")
```

## Gap statistic method
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "gap_stat")
```

## NbClust() function: 30 indices for choosing the best number of clusters
NbClust::NbClust() use kmeans() and hcluster to compute cluster.

* kmeans() take dataset and only use euclidean to compute distance by itself.

* hclust take distance provided by outside to compute.

```{r include=FALSE}

nbclust_res <- tidyr::expand_grid(
  method = c(
    "kmeans", "ward.D", "ward.D2", "single",
    "complete", "average", "median", "centroid"
  ),
  metric = metric
)

nbclust_res <- nbclust_res %>%
  dplyr::left_join(dist_metric, by = "metric") %>%
  dplyr::arrange(metric, method) %>%
  dplyr::select(-("plot"))

# Get major best number of clusters from result of NbClust::NbClust()
major_best_nc <- function(x) {

  # Validate parameters
  stopifnot(inherits(x, "list"), "Best.nc" %in% names(x))

  # According to the majority rule, find best numbers of clusters
  best_ncs <- x$Best.nc
  if (class(best_ncs) == "numeric") {
    major_best_nc <- best_ncs
  } else if (class(best_ncs) == "matrix") {
    best_ncs <- as.data.frame(t(best_ncs), stringsAsFactors = TRUE)
    # Use mode number as major best number of clusters
    summary_best_ncs <- table(best_ncs$Number_clusters)
    major_best_nc <- as.numeric(names(which.max(summary_best_ncs)))
  }

  major_best_nc
}

nbclust_res <- nbclust_res %>%
  dplyr::rowwise() %>%
  dplyr::mutate(
    NbClust = list(NbClust::NbClust(
      data = df_cluster,
      diss = .data$dist,
      distance = NULL, method = .data$method
    )),
    major_best_nc = major_best_nc(.data$NbClust),
    NbcClust_plot = list(factoextra::fviz_nbclust(.data$NbClust) +
      labs(subtitle = glue::glue("{.data$metric}-{.data$method}")))
  )
```

```{r}
# Use mode number of best_nc as recommended best number of clusters
recommend_best_nc <- as.numeric(
  names(which.max(table(nbclust_res$major_best_nc)))
)
cat(
  paste0(
    "According to the majority rule, find best numbers of clusters: ",
    recommend_best_nc
  )
)

# Plot NbcClust
gridExtra::marrangeGrob(
  grobs = nbclust_res$NbcClust_plot,
  ncol = 2, nrow = 2
)
```

# Partitioning Clustering
## K-Means Clustering(kmeans())
### use factoextra::fviz_nbclust() to choose optimal k
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "silhouette")

df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "wss")

df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = kmeans, method = "gap_stat")
```

### Find clusers by kmeans()
```{r}
km_res <- df_cluster %>%
  kmeans(centers = recommend_best_nc, nstart = 25)

cluster_result_km <- cbind(
  cluster = km_res$cluster,
  df_cluster_indcd,
  df_cluster
)

cluster_result_km <- cluster_result_km %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_km,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot clusters
```{r}
p <- factoextra::fviz_cluster(km_res,
  data = df_cluster,
  geom = "point", pointsize = 1,
  ggtheme = theme_minimal()
)
plotly::ggplotly(p)
```

### Cluster mapping to industry and stocks
```{r}
cluster_mapping_km <- cluster_result_km %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_km,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```


## K-Medoids Clustering (pam()/pamk())
### Use factoextra::fviz_nbclust() choose optimal k
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::pam, method = "silhouette")

df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::pam, method = "wss")

df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::pam, method = "gap_stat")
```

### Find clusers by cluster:pam()/fpc::pamk()
```{r}
# Find clusers by cluster:pam()
pam_res <- df_cluster %>%
  cluster::pam(k = recommend_best_nc)

# Find clusters by fpc::pamk()
pamk_res <- df_cluster %>%
  fpc::pamk()

pam_res_2 <- pamk_res$pamobject
pamk_res$nc

cluster_result_pam <- cbind(
  cluster = pam_res$cluster,
  df_cluster_indcd,
  df_cluster
)

cluster_result_pam <- cluster_result_pam %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_pam,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot clusters
```{r}
p_pam_1 <- factoextra::fviz_cluster(pam_res,
  data = df_cluster,
  ellipse.type = "t", # Concentration ellipse
  geom = "point", pointsize = 1,
  # repel = TRUE, # Avoid label overplotting (slow)
  ggtheme = theme_minimal()
)

p_pam_2 <- factoextra::fviz_cluster(pam_res,
  data = df_cluster,
  geom = "point", pointsize = 1,
  ggtheme = theme_minimal()
)

p_pamk_1 <- factoextra::fviz_cluster(pam_res_2,
  data = df_cluster,
  geom = "point", pointsize = 1,
  ggtheme = theme_minimal()
)
gridExtra::marrangeGrob(list(p_pam_1, p_pam_2, p_pamk_1), ncol = 2, nrow = 2)
```

### Cluster mapping to industry and stocks
```{r}
cluster_mapping_pam <- cluster_result_pam %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_pam,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Comapring by various distance metric
```{r}
pc_clusters_pam <- tidyr::expand_grid(
  metric = metric
)

pc_clusters_pam <- pc_clusters_pam %>%
  dplyr::left_join(dist_metric, by = "metric") %>%
  dplyr::select(-("plot"))

pc_clusters_pam <-
  pc_clusters_pam %>%
  rowwise() %>%
  dplyr::mutate(pam_res = list(cluster::pam(
    x = .data$dist, k = recommend_best_nc
  )))

# Notice: if you use dist instead of data to compute PAM,
# the result of pam doesn't contain data field which will
# lead failure of fviz_cluster.
# pc_clusters_pam <-
#   pc_clusters_pam %>%
#   dplyr::mutate(
#     plot = list(factoextra::fviz_cluster(.data$pam_res,
#       data = df_cluster,
#       geom = "point", pointsize = 1
#     )
#     + labs(subtitle = glue::glue("{.data$metric}")))
#   )

pc_clusters_pam <-
  pc_clusters_pam %>%
  dplyr::mutate(
    plot = list(factoextra::fviz_cluster(
      list(data = df_cluster, cluster = .data$pam_res$clustering),
      geom = "point", pointsize = 1
    )
    + labs(subtitle = glue::glue("{.data$metric}")))
  )

gridExtra::marrangeGrob(
  grobs = pc_clusters_pam$plot,
  ncol = 2, nrow = 2
)
```


## Clustering Large Applications(clara())


### Use fviz_nbclust() choose optimal k
```{r}
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::clara, method = "silhouette")
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::clara, method = "wss")
df_cluster %>%
  factoextra::fviz_nbclust(FUNcluster = cluster::clara, method = "gap_stat")
```


### Find clusters by cluster
```{r}
clara_res <- df_cluster %>%
  dplyr::select(where(is.numeric)) %>%
  cluster::clara(k = recommend_best_nc, samples = 50, pamLike = TRUE)

cluster_result_clara <- cbind(df_cluster,
  cluster = clara_res$cluster,
  df_cluster_indcd,
  df_cluster
)


cluster_result_clara <- cluster_result_clara %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_clara,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot cluster
```{r}
p <- factoextra::fviz_cluster(clara_res,
  geom = "point", pointsize = 1,
  ggtheme = theme_classic()
)
plotly::ggplotly(p)
```


### Cluster mapping to industry and stocks
```{r}
cluster_mapping_clara <- cluster_result_clara %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_clara,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```


# Hierarchical Clustering
## hclust()
### Find cluster by hclust()
```{r}
dist_res <- df_cluster %>%
  select(where(is.numeric)) %>%
  dist(method = "euclidean")
hc_res <- hclust(d = dist_res, method = "complete")
hc_res_coph <- cophenetic(hc_res)
cor(dist_res, hc_res_coph)

hc_group <- cutree(hc_res, k = recommend_best_nc)

cluster_result_hc <- cbind(
  cluster = hc_group,
  df_cluster_indcd,
  df_cluster
)

cluster_result_hc <- cluster_result_hc %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_hc,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot dendgram and clusters
```{r}
factoextra::fviz_dend(hc_res,
  k = recommend_best_nc, cex = 0.5, rect = TRUE, horiz = TRUE
)

factoextra::fviz_cluster(list(data = df_cluster, cluster = hc_group),
  ellipse.type = "convex", # Concentration ellipse
  repel = TRUE, # Avoid label overplotting (slow)
  geom = "point",
  show.clust.cent = FALSE, ggtheme = theme_minimal()
)
```

### Cluster mapping to industry and stocks
```{r}
cluster_mapping_hc <- cluster_result_hc %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_hc,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Comparing by various distance and link method
```{r}
hc_clusters_hclust <- tidyr::expand_grid(
  methods = c(
    "ward.D", "ward.D2", "single", "complete",
    "average", "mcquitty", "median", "centroid"
  ),
  metric = metric
)

hc_clusters_hclust <- hc_clusters_hclust %>%
  dplyr::filter(!(metric %in% c("manhattan"))) %>%
  dplyr::left_join(dist_metric, by = "metric") %>%
  dplyr::select(-("plot"))


hc_clusters_hclust <-
  hc_clusters_hclust %>%
  rowwise() %>%
  dplyr::mutate(hc_res = list(hclust(
    d = .data$dist,
    method = .data$methods
  )))

hc_clusters_hclust <-
  hc_clusters_hclust %>%
  dplyr::mutate(
    plot = list(factoextra::fviz_dend(.data$hc_res,
      cex = 0.6, k = recommend_best_nc
    )
    + labs(subtitle = glue::glue("{.data$metric} - {.data$methods}")))
  )


gridExtra::marrangeGrob(
  grobs = hc_clusters_hclust$plot,
  ncol = 2, nrow = 2
)
```

## Cluster::agnes() - Agglomerative clustering
### Find cluster by agens()
```{r}
# Agglomerative Nesting (Hierarchical Clustering)
agnes_res <- cluster::agnes(
  x = df_cluster, # data matrix
  stand = TRUE, # Standardize the data
  metric = "euclidean", # metric for distance matrix
  method = "ward" # Linkage method
)

hc_group <- cutree(agnes_res, k = recommend_best_nc)

cluster_result_agnes <- cbind(
  cluster = hc_group,
  df_cluster_indcd,
  df_cluster
)

cluster_result_agnes <- cluster_result_agnes %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_agnes,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot dendgram and clusters
```{r}
# Plot dendrogram
factoextra::fviz_dend(agnes_res,
  k = recommend_best_nc,
  cex = 0.5, rect = TRUE, horiz = TRUE
)
factoextra::fviz_dend(agnes_res,
  k = recommend_best_nc,
  cex = 0.5, type = "circular"
)
factoextra::fviz_dend(agnes_res,
  k = recommend_best_nc,
  cex = 0.5, type = "phylogenic"
)

# Plot clusters
factoextra::fviz_cluster(list(data = df_cluster, cluster = hc_group),
  ellipse.type = "convex", # Concentration ellipse
  repel = TRUE, # Avoid label overplotting (slow)
  geom = "point",
  show.clust.cent = FALSE, ggtheme = theme_minimal()
)
```

### Cluster mapping to industries and stocks
```{r}
cluster_mapping_agnes <- cluster_result_agnes %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_agnes,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Comapring by various distance metric and link method
```{r}
hc_clusters_agnes <- tidyr::expand_grid(
  methods = c("average", "single", "complete", "ward", "weighted"),
  metric = metric
)

hc_clusters_agnes <- hc_clusters_agnes %>%
  dplyr::left_join(dist_metric, by = "metric") %>%
  dplyr::select(-("plot"))

hc_clusters_agnes <-
  hc_clusters_agnes %>%
  rowwise() %>%
  dplyr::mutate(agnes_res = list(cluster::agnes(
    x = .data$dist,
    method = .data$methods
  )))

hc_clusters_agnes <-
  hc_clusters_agnes %>%
  dplyr::mutate(
    plot = list(factoextra::fviz_dend(.data$agnes_res,
      cex = 0.6, k = recommend_best_nc
    )
    + labs(subtitle = glue::glue("{.data$metric} - {.data$methods}")))
  )


gridExtra::marrangeGrob(
  grobs = hc_clusters_agnes$plot,
  ncol = 2, nrow = 2
)
```

## Cluster::diana() - Divisive clustering
### Find cluster by diana()
```{r}
# Divisive clustering
diana_res <- cluster::diana(
  x = df_cluster, # data matrix
  stand = TRUE, # Standardize the data
  metric = "euclidean", # metric for distance matrix
)

hc_group <- cutree(diana_res, k = recommend_best_nc)

cluster_result_diana <- cbind(
  cluster = hc_group,
  df_cluster_indcd,
  df_cluster
)

cluster_result_diana <- cluster_result_diana %>%
  dplyr::select(indcd, cluster) %>%
  tibble::rownames_to_column(var = "stkcd") %>%
  dplyr::mutate(
    indname = zstexplorer:::code2name(indcd),
    stkname = zstexplorer:::code2name(stkcd)
  ) %>%
  dplyr::select(stkcd, stkname, indcd, indname, cluster)


DT::datatable(cluster_result_diana,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Plot dendgram and clusters
```{r}
# Plot dendrogram
factoextra::fviz_dend(diana_res,
  k = recommend_best_nc,
  cex = 0.5, rect = TRUE, horiz = TRUE
)
factoextra::fviz_dend(diana_res,
  k = recommend_best_nc,
  cex = 0.5, type = "circular"
)
factoextra::fviz_dend(diana_res,
  k = recommend_best_nc,
  cex = 0.5, type = "phylogenic"
)

# Plot clusters
factoextra::fviz_cluster(list(data = df_cluster, cluster = hc_group),
  ellipse.type = "convex", # Concentration ellipse
  repel = TRUE, # Avoid label overplotting (slow)
  geom = "point",
  show.clust.cent = FALSE, ggtheme = theme_minimal()
)
```

### Cluster mapping to industry and stocks
```{r}
cluster_mapping_diana <- cluster_result_diana %>%
  dplyr::nest_by(cluster) %>%
  dplyr::mutate(
    indcds = list(sort(unique(data$indcd))),
    indnames = list(sort(unique(data$indname))),
    stkcds = list(sort(unique(data$stkcd))),
    stknames = list(sort(unique(data$stkname)))
  ) %>%
  dplyr::select(-c("data", "indcds", "stkcds"))

DT::datatable(cluster_mapping_diana,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### Comparing by various disatance metric
```{r}
hc_clusters_diana <- tidyr::expand_grid(
  metric = metric
)

hc_clusters_diana <- hc_clusters_diana %>%
  dplyr::left_join(dist_metric, by = "metric") %>%
  dplyr::select(-("plot"))

hc_clusters_diana <-
  hc_clusters_diana %>%
  rowwise() %>%
  dplyr::mutate(agnes_res = list(cluster::diana(
    x = .data$dist
  )))

hc_clusters_diana <-
  hc_clusters_diana %>%
  dplyr::mutate(
    plot = list(factoextra::fviz_dend(.data$agnes_res,
      cex = 0.6, k = recommend_best_nc
    )
    + labs(subtitle = glue::glue("{.data$metric}")))
  )


gridExtra::marrangeGrob(
  grobs = hc_clusters_diana$plot,
  ncol = 2, nrow = 2
)
```

# Choose the best clustering algorithm
Compares clustering algorithms using two cluster validation measures:

* **Internal measures**, which uses intrinsic information in the data to assess the quality of the clustering. Internal measures include the connectivity, the silhouette coefficient and the Dunn index .

  + Silhouette coefficient

    The silhouette measures how well an observation is clustered and it estimates the average distance between clusters.

  **Rule to judge:** Silhouette coefficient should be maximized

  + Dunn index

    The Dunn Index is the ratio of the smallest distance between observations not in the same cluster to the largest intra-cluster distance.

  **Rule to judge:** The Dunn Index has a value between zero and infinity, and should be maximized

  + Connectivity

    The connectivity indicates the degree of connectedness of the clusters, as determined by the k-nearest neighbors.

  It corresponds to what extent items are placed in the same cluster as their nearest neighbors in the data space.

  **Rule to judge:** The connectivity has a value between 0 and infinity and should be minimized.

* **Stability measures**, a special version of internal measures, which evaluates the consistency of a clustering result by comparing it with the clusters obtained after each column is removed, one at a time.

  + The average proportion of non-overlap (APN)

  The APN measures the average proportion of observations not placed in the same cluster by clustering based on the full data and clustering based on the data with a single column removed.

  + The average distance (AD)

    The AD measures the average distance between observations placed in the same cluster under both cases (full data set and removal of one column).

  + The average distance between means (ADM)

    The ADM measures the average distance between cluster centers for observations placed in the same cluster under both cases.

  + The figure of merit (FOM)

    The FOM measures the average intra-cluster variance of the deleted column, where the clustering is based on the remaining (undeleted) columns.

  The APN, AD, and ADM are all based on the cross-classification table of the original clustering on the full data with the clustering based on the removal of one column.

  **Rule to judge:**

  The values of APN, ADM and FOM ranges from 0 to 1, with smaller value corresponding with highly consistent clustering results. AD has a value between 0 and infinity, and smaller values are also preferred.
    
## Compute Internal measures
```{r}
# Compute internal measures by clValid
clmethods <- c("kmeans", "pam", "clara", "hierarchical", "agnes", "diana")
internal_measure <- clValid::clValid(
  as.matrix(df_cluster),
  nClust = 2:6,
  clMethods = clmethods,
  metric = "euclidean",
  method = "complete",
  validation = "internal"
)

# Summary
summary(internal_measure)

plot(internal_measure, ask = FALSE)
```

## Compute Stability measures
```{r}
# Compute stability measures by clValid
clmethods <- c("kmeans", "pam", "clara", "hierarchical", "agnes", "diana")
stability_measure <- clValid::clValid(
  as.matrix(df_cluster),
  nClust = 2:6,
  clMethods = clmethods,
  metric = "euclidean",
  method = "complete",
  validation = "stability"
)

# Summary
summary(stability_measure)

plot(stability_measure, ask = FALSE)
```

# Hierarchical Clustering with P-Values

## Compute P-value for Hierarchical Clustering

Clusters can be found in a data set by chance due to clustering noise or sampling error. By conducting multiscale bootstrap resampling, we could find hierarchical 
clustering above specified P-Values.

**Algorithm:**

1. Generated thousands of bootstrap samples by randomly sampling elements of the data

2. Compute hierarchical clustering on each bootstrap copy

3. For each cluster:

  + compute the **bootstrap probability (BP) value** which corresponds to the frequency that the cluster is identified in bootstrap copies.

  + Compute the **approximately unbiased (AU) probability values** (p-values) by multiscale bootstrap resampling.

**Notice on Cluster dendrogram with AU/BP values:**

  Values on the dendrogram are AU p-values (Red, left), BP values (green, right),
and clusterlabels (grey, bottom). 

**Rule to judge:**

Clusters with AU > = 95% are indicated by the rectangles and are considered to be strongly supported by data.


```{r}
set.seed(123)
pv_res <- pvclust::pvclust(
  t(df_cluster),
  method.dist = "cor",
  method.hclust = "complete", nboot = 10
)
```

## Pick Clusters above P-values to map to stocks

```{r}

# Pick cluster above p-values

# Plot picked clusters
plot(pv_res, hang = -1, cex = 0.5)
pvclust::pvrect(pv_res, alpha = 0.95)

# Map picked clusters to stkcd
pvpick_res <- pvclust::pvpick(pv_res, alpha = 0.95)
pick_pv_clusters <- tibble::tibble(
  id = 1:length(pvpick_res$clusters),
  pick_clusters = pvpick_res$clusters
)

pick_pv_clusters <- pick_pv_clusters %>%
  dplyr::rowwise() %>%
  dplyr::mutate(stkcds = list(zstexplorer:::code2name(.data$pick_clusters)))

DT::datatable(pick_pv_clusters,
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 10,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 360,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```
## Appendix {-}

### A.1 Indcd reference {-}

```{r, cache = TRUE, class.source = 'fold-hide'}
stock_db <- zstexplorer::stock_db()
industry_info <- zstmodelr::get_industry_info(stock_db)

DT::datatable(industry_info,
  caption = "Information about indcd",
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### A.2 Stkcd reference {-}

```{r, cache = TRUE, class.source = 'fold-hide'}
stock_db <- zstexplorer::stock_db()
stock_info <- zstmodelr::get_stock_info(stock_db)

DT::datatable(stock_info,
  caption = "Information about stkcd",
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### A.3 Factor reference {-}

```{r, cache = TRUE, class.source = 'fold-hide'}
stock_db <- zstexplorer::stock_db()
factors_info <- zstmodelr::get_factors_info(stock_db)

DT::datatable(factors_info,
  caption = "Information about factors",
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```

### A.4 Indicator reference {-}

```{r, cache = TRUE, class.source = 'fold-hide'}
stock_db <- zstexplorer::stock_db()
indicators_info <- zstmodelr::get_indicators_info(stock_db)

DT::datatable(indicators_info,
  caption = "Information about indicators",
  filter = "top",
  extensions = "Scroller",
  options = list(
    columnDefs = list(list(className = "dt-center")),
    pageLength = 5,
    dom = "ltir",
    deferRender = TRUE,
    scrollY = 180,
    scrollX = TRUE,
    scroller = TRUE
  )
)
```
